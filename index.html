<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vinpearl Aquarium Royal City 3D - Upgraded</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a1d37, #1b3f6a);
        }
        canvas {
            display: block;
            filter: brightness(0.95) contrast(1.1);
        }
        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #e0f7fa;
            text-shadow: 0 0 12px rgba(0, 191, 255, 0.9);
            font-size: 3em;
            font-family: 'Arial', sans-serif;
            z-index: 10;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #e0f7fa;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.8);
            font-family: Arial, sans-serif;
            z-index: 10;
            text-align: center;
        }
        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: bubbleRise 2.5s infinite ease-in;
        }
        @keyframes bubbleRise {
            0% { transform: translateY(0); opacity: 0.9; }
            100% { transform: translateY(-100vh) translateX(${Math.random() * 30 - 15}px); opacity: 0; }
        }
        .water-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(0, 191, 255, 0.15), rgba(0, 105, 180, 0.3));
            pointer-events: none;
            animation: wave 12s infinite linear;
            z-index: 5;
        }
        @keyframes wave {
            0% { background-position: 0 0; }
            100% { background-position: 1000px 0; }
        }
    </style>
</head>
<body>
    <h1>Vinpearl Aquarium Royal City</h1>
    <div class="instructions">Click to lock mouse | WASD to move | Mouse to look around</div>
    <div class="water-overlay"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/yuka@latest/build/yuka.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Camera initial position
        camera.position.set(0, 1.5, 15);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0x00b7eb, 0.8);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const pointLight = new THREE.PointLight(0x00e5ff, 0.5, 50);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // Load environment map for reflections
        const loader = new THREE.RGBELoader();
        loader.load('https://dl.polyhaven.com/file/ph-assets/HDRIs/hdr/1k/underwater_studio_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
        });

        // Aquarium tunnel walls with water normals for distortion
        const waterNormals = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/waternormals.jpg');
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

        const wallGeometry = new THREE.PlaneGeometry(50, 4);
        const wallMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00b7eb,
            transparent: true,
            opacity: 0.25,
            roughness: 0.05,
            metalness: 0.2,
            reflectivity: 1.0,
            transmission: 0.9,
            side: THREE.DoubleSide,
            normalMap: waterNormals,
            normalScale: new THREE.Vector2(0.1, 0.1)
        });
        const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
        leftWall.position.set(-3, 1.5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
        rightWall.position.set(3, 1.5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Floor with sand texture
        const floorGeometry = new THREE.PlaneGeometry(6, 50);
        const floorDiffuse = new THREE.TextureLoader().load('https://3dtextures.me/wp-content/uploads/2020/06/Stylized_Sand_001_basecolor.jpg');
        floorDiffuse.wrapS = floorDiffuse.wrapT = THREE.RepeatWrapping;
        floorDiffuse.repeat.set(1, 5);
        const floorNormal = new THREE.TextureLoader().load('https://3dtextures.me/wp-content/uploads/2020/06/Stylized_Sand_001_normal.jpg');
        floorNormal.wrapS = floorNormal.wrapT = THREE.RepeatWrapping;
        floorNormal.repeat.set(1, 5);
        const floorRoughness = new THREE.TextureLoader().load('https://3dtextures.me/wp-content/uploads/2020/06/Stylized_Sand_001_roughness.jpg');
        floorRoughness.wrapS = floorRoughness.wrapT = THREE.RepeatWrapping;
        floorRoughness.repeat.set(1, 5);
        const floorMaterial = new THREE.MeshStandardMaterial({
            map: floorDiffuse,
            normalMap: floorNormal,
            roughnessMap: floorRoughness,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Coral and seaweed (keep as is, but add shadows)
        // (Code for coral and seaweed from previous, with castShadow = true)

        // Load GLTF fish model
        const gltfLoader = new THREE.GLTFLoader();
        let fishModel;
        gltfLoader.load('https://poly.pizza/m/52s3JpUSjmX/download', (gltf) => {
            fishModel = gltf.scene;
            fishModel.scale.set(0.5, 0.5, 0.5); // Adjust scale
            fishModel.traverse(child => {
                if (child.isMesh) child.castShadow = true;
            });
            // Clone and animate
            for (let i = 0; i < 20; i++) {
                const clone = fishModel.clone();
                const vehicle = new YUKA.Vehicle();
                vehicle.setRenderComponent(clone, sync);
                vehicle.position.copy(clone.position);
                entityManager.add(vehicle);
                vehicle.steering.add(new YUKA.WanderBehavior());
            }
        });

        // Yuka setup for AI movement
        const entityManager = new YUKA.EntityManager();
        const time = new YUKA.Time();
        function sync(entity, renderComponent) {
            renderComponent.matrix.copy(entity.worldMatrix);
        }

        // Bubbles, movement controls, animation loop (keep from previous)
        // Update in animate: time.update(); entityManager.update(time.delta); and normals.offset.x += 0.001 for wave
        waterNormals.offset.x += 0.001; // For moving normals

        // ... (rest of code)
    </script>
</body>
</html>



